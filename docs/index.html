<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<head>
<title>GLITFENESTRO: Sliding Window</title>
<link type='text/css' href='style.css' rel='stylesheet'/>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<script src="jquery.min.js"></script>
<script src="toc.min.js"></script>
<script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         inlineMath: [['$','$']],
         processEscapes: true
       }
     });
   </script>
   <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
   </script>
   </head>
<body>
<div id="content-container">
<div id="toc">
<div id="page-toc">
</div>
<div id="toc-footer"><ul><li><a href="https://github.com/melisgl/mgl-pax">[generated by MGL-PAX]</a></li></ul></div>
</div>
<div id="content">
<p><a id='x-28GLITFENESTRO-2EDOCS-3A-40INDEX-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28GLITFENESTRO-2EDOCS-3A-40ASDF-DETAILS-20MGL-PAX-3ASECTION-29" title="ASDF Details">&#8594;</a> <a href="#x-28GLITFENESTRO-2EDOCS-3A-40INDEX-20MGL-PAX-3ASECTION-29" title="GLITFENESTRO: Sliding Window">&#8634;</a></span></span></p>

<h1><a href="#x-28GLITFENESTRO-2EDOCS-3A-40INDEX-20MGL-PAX-3ASECTION-29">GLITFENESTRO: Sliding Window</a></h1>

<h2>Table of Contents</h2>

<ul>
<li><a href="#x-28GLITFENESTRO-2EDOCS-3A-40ASDF-DETAILS-20MGL-PAX-3ASECTION-29" title="ASDF Details">1 ASDF Details</a></li>
<li><a href="#x-28GLITFENESTRO-2EDOCS-3A-40SYSTEM-DETAILS-20MGL-PAX-3ASECTION-29" title="System Details">2 System Details</a></li>
<li><a href="#x-28GLITFENESTRO-3A-40ITERATE-20MGL-PAX-3ASECTION-29" title="Iterate Drivers">3 Iterate Drivers</a>

<ul>
<li><a href="#x-28GLITFENESTRO-3A-40WINDOWING-BY-20MGL-PAX-3ASECTION-29" title="WINDOWING-BY">3.1 WINDOWING-BY</a></li>
<li><a href="#x-28GLITFENESTRO-3A-40WINDOWING-IF-20MGL-PAX-3ASECTION-29" title="WINDOWING-IF">3.2 WINDOWING-IF</a></li>
</ul></li>
</ul>

<h6>[in package GLITFENESTRO.DOCS with nicknames GFRO-DOCS]</h6>

<p><code>GLITFENESTRO</code> is a package for analysis of sequences using sliding windows. A <em>window</em> or <em>frame</em> is a subsequence of consecutive elements sampled from the main sequence. Typical examples of applications of window functions include rolling averages, cumulative sums, and more complex things such as rolling regressions<sup><a href="#r-slider" >1</a></sup>.
<blockquote class="note">
GLITFENESTRO (<em>Esperanto</em>) &lt;==&gt; Sliding Window (<em>English</em>)
</blockquote>
This package contains,</p>

<ol>
<li><p>drivers for the <code>iterate</code> package and</p></li>
<li><p><code>map</code> functions</p></li>
</ol>

<p>that provide flexible sliding window functionality for analyzing sequences. See GLITFENESTRO.DOCS:@API-REFERENCE for details.</p>

<p><a id='x-28GLITFENESTRO-2EDOCS-3A-40ASDF-DETAILS-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28GLITFENESTRO-2EDOCS-3A-40INDEX-20MGL-PAX-3ASECTION-29" title="GLITFENESTRO: Sliding Window">&#8592;</a> <a href="#x-28GLITFENESTRO-2EDOCS-3A-40INDEX-20MGL-PAX-3ASECTION-29" title="GLITFENESTRO: Sliding Window">&#8593;</a> <a href="#x-28GLITFENESTRO-2EDOCS-3A-40SYSTEM-DETAILS-20MGL-PAX-3ASECTION-29" title="System Details">&#8594;</a> <a href="#x-28GLITFENESTRO-2EDOCS-3A-40ASDF-DETAILS-20MGL-PAX-3ASECTION-29" title="ASDF Details">&#8634;</a></span></span></p>

<h2><a href="#x-28GLITFENESTRO-2EDOCS-3A-40ASDF-DETAILS-20MGL-PAX-3ASECTION-29">1 ASDF Details</a></h2>

<ul>
<li><p><strong>Version</strong>: 1.0.0</p></li>
<li><p><strong>Description</strong>: Skeleton template for Lisp project with test and documentation generator.</p></li>
<li><p><strong>License</strong>: Unlicense.</p></li>
<li><p><strong>Author</strong>: Prashanth Kumar</p></li>
<li><p><strong>Mailto</strong>: prasxanth.kumar@gmail.com</p></li>
<li><p><strong>Homepage</strong>: http://prasxanth.github.io/glitfenestro/</p></li>
<li><p><strong>Bug tracker</strong>: https://github.com/prasxanth/glitfenestro/issues</p></li>
<li><p><strong>Source control</strong>: http://github.com/glitfenestro.git</p></li>
</ul>

<p><a id='x-28GLITFENESTRO-2EDOCS-3A-40SYSTEM-DETAILS-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28GLITFENESTRO-2EDOCS-3A-40ASDF-DETAILS-20MGL-PAX-3ASECTION-29" title="ASDF Details">&#8592;</a> <a href="#x-28GLITFENESTRO-2EDOCS-3A-40INDEX-20MGL-PAX-3ASECTION-29" title="GLITFENESTRO: Sliding Window">&#8593;</a> <a href="#x-28GLITFENESTRO-3A-40ITERATE-20MGL-PAX-3ASECTION-29" title="Iterate Drivers">&#8594;</a> <a href="#x-28GLITFENESTRO-2EDOCS-3A-40SYSTEM-DETAILS-20MGL-PAX-3ASECTION-29" title="System Details">&#8634;</a></span></span></p>

<h2><a href="#x-28GLITFENESTRO-2EDOCS-3A-40SYSTEM-DETAILS-20MGL-PAX-3ASECTION-29">2 System Details</a></h2>

<p>This package was developed and tested on,</p>

<ul>
<li><p><strong>OS</strong>: macOS Big Sur</p></li>
<li><p><strong>Processor</strong>: 2.3 GHz 8-Core Intel Core i9</p></li>
<li><p><strong>Memory</strong>: 16 GB 2667 MHz DDR4</p></li>
<li><p><strong>Lisp</strong>: SBCL 2.1.3</p></li>
<li><p><strong>IDE</strong>: EMACS SLIME</p></li>
</ul>

<p><a id='x-28GLITFENESTRO-3A-40ITERATE-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28GLITFENESTRO-2EDOCS-3A-40SYSTEM-DETAILS-20MGL-PAX-3ASECTION-29" title="System Details">&#8592;</a> <a href="#x-28GLITFENESTRO-2EDOCS-3A-40INDEX-20MGL-PAX-3ASECTION-29" title="GLITFENESTRO: Sliding Window">&#8593;</a> <a href="#x-28GLITFENESTRO-3A-40WINDOWING-BY-20MGL-PAX-3ASECTION-29" title="WINDOWING-BY">&#8594;</a> <a href="#x-28GLITFENESTRO-3A-40ITERATE-20MGL-PAX-3ASECTION-29" title="Iterate Drivers">&#8634;</a></span></span></p>

<h2><a href="#x-28GLITFENESTRO-3A-40ITERATE-20MGL-PAX-3ASECTION-29">3 Iterate Drivers</a></h2>

<h6>[in package GLITFENESTRO with nicknames GFRO]</h6>

<p>Two drivers are defined for the <a href="https://common-lisp.net/project/iterate/doc/index.html" >iterate</a> package,
<strong><code>WINDOWING-BY</code></strong> and <strong><code>WINDOWING-IF</code></strong>. <strong><code>WINDOWING-BY</code></strong> is for fixed or variable window size. <strong><code>WINDOWING-IF</code></strong> is for window sizes that satisfy a predicate.</p>

<p><a id='x-28GLITFENESTRO-3A-40WINDOWING-BY-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28GLITFENESTRO-3A-40ITERATE-20MGL-PAX-3ASECTION-29" title="Iterate Drivers">&#8592;</a> <a href="#x-28GLITFENESTRO-3A-40ITERATE-20MGL-PAX-3ASECTION-29" title="Iterate Drivers">&#8593;</a> <a href="#x-28GLITFENESTRO-3A-40WINDOWING-IF-20MGL-PAX-3ASECTION-29" title="WINDOWING-IF">&#8594;</a> <a href="#x-28GLITFENESTRO-3A-40WINDOWING-BY-20MGL-PAX-3ASECTION-29" title="WINDOWING-BY">&#8634;</a></span></span></p>

<h3><a href="#x-28GLITFENESTRO-3A-40WINDOWING-BY-20MGL-PAX-3ASECTION-29">3.1 WINDOWING-BY</a></h3>

<p><strong>DEFINITION</strong></p>

<pre><code><span class="code">FOR binding-form SLIDING-ACROSS seq WINDOWING-BY size SKIPPING-BY skip</span></code></pre>

<p><strong>SYNOPSIS</strong></p>

<p>Iterate by fixed or variable window size sliding across a sequence</p>

<p><strong><code>KEYWORD</code> ARGUMENTS</strong></p>

<p><code>BINDING-FORM</code> -- a variable or two-variable proper list</p>

<p><code>SEQ</code> -- a proper sequence</p>

<p><code>SIZE</code> -- an integer or proper sequence of integers</p>

<p><code>SKIP</code> -- an integer or proper sequence of integers</p>

<p><strong><code>RETURN</code> <code>VALUES</code></strong></p>

<p>For each iteration, a sequence of length <code>SIZE</code>.</p>

<p><strong>DESCRIPTION</strong></p>

<p>A single variable <code>BINDING-FORM</code> contains the window sub-sequence for each iteration. For a list pair <code>BINDING-FORM</code>, the first variable contains the window sub-sequence and the second is a list pair containing the window start and end indices.</p>

<p>This driver is useful when iterating a fixed or variable sliding window across a sequence. Each iteration returns a sub-sequence of size <code>SIZE</code> after skipping <code>SKIP</code> elements in the sequence (see examples for further details).</p>

<p><strong>NOTES</strong></p>

<p>The following is assumed in all examples that follow,</p>

<pre><code><span class="code">CL-USER&gt; <span class="paren1">(<span class="code">ql:quickload <span class="keyword">:glitfenestro</span></span>)</span>
CL-USER&gt; <span class="paren1">(<span class="code">ql:quickload <span class="keyword">:iterate</span></span>)</span>
CL-USER&gt; <span class="paren1">(<span class="code">use-package <span class="keyword">:iterate</span></span>)</span></span></code></pre>

<p><details open>
<summary> <strong><em>Basic Use</em></strong> </summary></p>

<p>The most basic use is with fixed size and skip,</p>

<pre><code>(iter
  (with seq = (alexandria:iota 20))
  (for w :sliding-across seq :windowing-by 2 :skipping-by 1)
  (collecting w))
=&gt; ((0 1) (3 4) (6 7) (9 10) (12 13) (15 16) (18 19))
</code></pre>

<p>Functionality of many of <code>Serapeum</code>'s sequence functions can be obtained using this driver.</p>

<p>A <code>SKIP</code> of 0 yields output similar to the <code>serapeum:batches</code>,</p>

<pre><code>(iter
  (with seq = (alexandria:iota 20))
  (for w :sliding-across seq :windowing-by 5 :skipping-by 0)
  (collecting w))
=&gt; ((0 1 2 3 4) (5 6 7 8 9) (10 11 12 13 14) (15 16 17 18 19))
</code></pre>

<pre><code>(serapeum:batches (alexandria:iota 20) 5)
=&gt; ((0 1 2 3 4) (5 6 7 8 9) (10 11 12 13 14) (15 16 17 18 19))
</code></pre>

<p>The iterate driver is more flexible of course! For example, overlap can be obtained using a  <em>negative</em> <code>SKIP</code>,</p>

<pre><code>(iter
   (with seq = (alexandria:iota 10))
   (for w :sliding-across seq :windowing-by 3 :skipping-by -1)
   (collecting w))
=&gt; ((0 1 2) (2 3 4) (4 5 6) (6 7 8))
</code></pre>

<pre><code>(iter
   (with seq = (alexandria:iota 10))
   (for w :sliding-across seq :windowing-by 3 :skipping-by -2)
   (collecting w))
=&gt; ((0 1 2) (1 2 3) (2 3 4) (3 4 5) (4 5 6) (5 6 7) (6 7 8) (7 8 9))
</code></pre>

<p></details></p>

<p><details>
<summary> <strong><em>Window Indices and Overhang</em></strong> </summary></p>

<p>Both the <code>SIZE</code> and <code>SKIP</code> can be numeric sequences. In such cases windowing only occurs until the shorter of <code>SIZE</code> or <code>SKIP</code>.</p>

<pre><code>(iter
  (with seq = (alexandria:iota 20))
  (for w :sliding-across seq
         :windowing-by '(2 2 2 2 2)
         :skipping-by '(1 1 1 1 1 1 1 1 1))
   (collecting w))
=&gt; ((0 1) (3 4) (6 7) (9 10))
</code></pre>

<p>Termination at a length shorter than the input sequence results in an <em>overhang</em>, i.e., the end sub-sequence that is not part of the iteration.</p>

<p>The &quot;full form&quot; of the driver returns two values: (1) the window contents (2) the window extent - a list with the start and end indices of the window. Thus one could obtain the indices in the above example by using the regular destructuring pattern,</p>

<pre><code>(iter
  (with seq = (alexandria:iota 20))
  (for (w i) :sliding-across seq
             :windowing-by '(2 2 2 2 2)
             :skipping-by '(1 1 1 1 1 1 1 1 1))
   (collecting (list w i)))
=&gt; (((0 1) (0 1)) ((3 4) (3 4)) ((6 7) (6 7)) ((9 10) (9 10)))
</code></pre>

<p>As an example of the usefulness of the indices, consider extrating the overhang in the previous example,</p>

<pre><code>(iter
  (with seq = (alexandria:iota 20))
  (with max-index = 0)
  (for (w i) :sliding-across seq
         :windowing-by '(2 2 2 2 2)
         :skipping-by '(1 1 1 1 1 1 1 1 1))
  (collecting w into result)
  (when (&gt; (cadr i) max-index) (setf max-index (cadr i)))
  (finally (return
         (nconc result
            (list (serapeum:slice seq
                      (1+ max-index)
                      (length seq)))))))
=&gt; ((0 1) (3 4) (6 7) (9 10) (11 12 13 14 15 16 17 18 19))
</code></pre>

<p>The overhang is provided by default in <code>serapeum:batches</code>, while it needs to be explicitly obtained when using the driver as shown above.</p>

<p>Of course the <code>SIZE</code> and <code>SKIP</code> lists can be heterogenous,</p>

<pre><code>(iter
  (with seq = (alexandria:iota 20))
  (for w :sliding-across seq
         :windowing-by '(2 3 0 1 1 2 3)
         :skipping-by '(-1 0 2 1 -2 0 3))
   (collecting w))
=&gt; ((0 1) (1 2 3) NIL (6) (8) (7 8))
</code></pre>

<p></details></p>

<p><details>
<summary> <strong><em>Aggregation</em></strong> </summary></p>

<p>Moving window aggregation is a very common operation in statistics. For example, the moving average (rolling average or running average) is used to analyze data points by creating a series of averages of different subsets of the full data set (see <a href="https://en.wikipedia.org/wiki/Moving_average" >Wikipedia</a>). A moving average with a window size of two for example is calculated as,</p>

<pre><code>(iter
  (with seq = (alexandria:iota 10))
  (for w :sliding-across seq
         :windowing-by 2
         :skipping-by -1)
  (collecting (funcall #'alexandria:mean w)))
=&gt; (1/2 3/2 5/2 7/2 9/2 11/2 13/2 15/2 17/2)
</code></pre>

<p>Likewise the moving window for any statistic can be obtained.</p>

<p>Differences between adjacent elements, called the first difference or successive difference, is used in calculation of the derivative,</p>

<pre><code>(iter
  (with seq = '(1 3 2 5 6 7 4 8 0))
  (for w :sliding-across seq
         :windowing-by 2
         :skipping-by -1)
  (collecting (reduce #'- w)))
=&gt; (-2 1 -3 -1 -1 3 -4 8)
</code></pre>

<p>Higher order derivatives can be calculated by repeating the above process using the sequence from previous differences.</p>

<p></details></p>

<p><details>
<summary> <strong><em>Recursion/Feedback</em></strong> </summary></p>

<p>The sequence itself may be modified with each iteration.</p>

<p>One useful instance is when generating sequences by recursion, starting from some seed value as demonstrated using the Fibonacci sequence below,</p>

<pre><code>(iter
  (with seq = '(0 1))
  (for w :sliding-across seq
         :windowing-by '(2 2 2 2 2 2 2)
         :skipping-by '(-1 -1 -1 -1 -1 -1 -1 -1))
  (for term = (reduce #'+ w))
  (collecting term)
  (setf seq (nconc seq (list term))))
=&gt; (1 2 3 5 8 13)
</code></pre>

<p>where the shorter of the <code>WINDOWING-BY</code> or <code>SKIPPING-BY</code> series determines the length of the generated sequence.
</details></p>

<p><details>
<summary> <strong><em>Scanning, Repeating, Cycling and Filtering</em></strong> </summary></p>

<p>Interesting functionality can be obtained by simply varying the <code>SKIPPING-BY</code> sequence.</p>

<p>For example, <code>serapeum:scan</code> can be reproduced as,</p>

<pre><code>(iter
  (with seq = (alexandria:iota 6))
  (for w :sliding-across seq
         :windowing-by '(1 2 3 4 5 6 7)
         :skipping-by '(-1 -2 -3 -4 -5 -6 -7))
  (collecting (reduce #'+ w)))
=&gt; (0 1 3 6 10 15)
</code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code">serapeum:scan #'+ <span class="paren2">(<span class="code">alexandria:iota 6</span>)</span></span>)</span>
=&gt; <span class="paren1">(<span class="code">0 1 3 6 10 15</span>)</span></span></code></pre>

<p>The driver is more flexible as it does not expect a reducing function. The equivalent of scanning using the <code>#'identity</code> function is easily realized,</p>

<pre><code>(iter
  (with seq = (alexandria:iota 6))
  (for w :sliding-across seq
         :windowing-by '(1 2 3 4 5 6 7)
         :skipping-by '(-1 -2 -3 -4 -5 -6 -7))
  (collecting w))
=&gt; ((0) (0 1) (0 1 2) (0 1 2 3) (0 1 2 3 4) (0 1 2 3 4 5))
</code></pre>

<p>Elements of a sequence can be selectively repeated. Consider repeating <code>2</code> twice and <code>4</code> four times in the sequence <code>0 1 2 3 4 5)</code>,</p>

<pre><code>(iter
  (with seq = (alexandria:iota 6))
  (for w :sliding-across seq
         :windowing-by '(1 1 1 1 1 1 1 1 1 1 1)
         :skipping-by '(0 0 -1 0 0 -1 -1 -1 0 0 0))
  (nconcing w))
=&gt; (0 1 2 2 3 4 4 4 4 5)
</code></pre>

<p><code>serapeum:repeat-sequence</code> replicates the entire sequence,</p>

<pre><code>(serapeum:repeat-sequence '(0 1 2 3 4 5) 3)
=&gt; (0 1 2 3 4 5 0 1 2 3 4 5 0 1 2 3 4 5)
</code></pre>

<p>This can be easily reproduced,</p>

<pre><code>(iter
  (with seq = (list (alexandria:iota 6)))
  (for w :sliding-across seq
         :windowing-by '(1 1 1 1)
         :skipping-by '(-1 -1 -1 0))
  (nconcing w into result)
  (finally (return (alexandria:flatten result))))
=&gt; (0 1 2 3 4 5 0 1 2 3 4 5 0 1 2 3 4 5)
</code></pre>

<p>Sequence elements can be repeated to produce a cycling effect,</p>

<pre><code>(iter
  (with seq = '(1 2 3))
  (for w :sliding-across seq
         :windowing-by '(3 3 3 3 3 3 3 3 3)
         :skipping-by '(-3 -3 -3 -3 -3 -3 -3 -3 -3))
  (nconcing w)
  (setq seq (nconc seq (list w))))
=&gt; (1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3)
</code></pre>

<p>The <code>SKIPPING-BY</code> parameter naturally provides position based filtering. Consider retaining only the elements divisible by three in a sequence from 1 to 10,</p>

<pre><code>(iter
  (with seq = (alexandria:iota 10))
  (for w :sliding-across seq
         :windowing-by '(1 1 1 1 1)
         :skipping-by '(2 2 2 2 2))
  (nconcing w))
=&gt; (0 3 6 9)
</code></pre>

<p></details></p>

<p><details>
<summary> <strong><em>Sequence Types</em></strong> </summary></p>

<p>The driver works on any proper sequence. Examples for vectors, strings and bit-vectors are provided below,</p>

<p><em>Vector</em></p>

<pre><code>(iter
  (with vec = #(0 1 2 3 4 5 6 7 8 9))
  (for w :sliding-across vec
         :windowing-by '(2 1 0 2 1 3 2 2)
         :skipping-by '(-1 2 -2 0 2 -1 1))
  (collecting w))
=&gt; (#(0 1) #(1) #() #(2 3) #(4) #(7 8 9))
</code></pre>

<p><em>String</em></p>

<pre><code>(iter
  (with str = "The quick brown fox jumped over the lazy dogs.")
  (for w :sliding-across str
         :windowing-by '(2 1 0 2 1 3 2 2)
         :skipping-by '(-1 2 -2 0 2 -1 1))
  (collecting w))
=&gt; ("Th" "h" "" "e " "q" "ck ")
</code></pre>

<p><em>Bit-vector</em></p>

<pre><code>(iter
  (with bit-vec = #*11001010001)
  (for w :sliding-across bit-vec
         :windowing-by '(2 1 0 2 1 3 2 2)
         :skipping-by '(-1 2 -2 0 2 -1 1))
  (collecting w))
=&gt; (#*11 #*1 #* #*00 #*1 #*000)
</code></pre>

<p>Note that the return type is a list with elements of <code>(type input-sequence)</code>.</p>

<p></details></p>

<p><details>
<summary> <strong><em>Nested Sequences</em></strong> </summary></p>

<p>Nested sequences are just another type of sequence so windowing will produce the expected results,</p>

<pre><code>(iter
  (with seq = '((1 2) (3 4 5) (6 7 8 9) 0))
  (for w :sliding-across seq
         :windowing-by '(2 1 0 2 1 3 2 2)
         :skipping-by '(-1 2 -2 0 2 -1 1))
  (collecting w))
=&gt; (((1 2) (3 4 5)) ((3 4 5)) NIL ((6 7 8 9) 0))
</code></pre>

<p></details></p>

<p><details>
<summary> <strong><em>Edge Cases</em></strong> </summary></p>

<p>An empty sequence returns <code>NIL</code>,
<code>cl-transcript
(iter
  (with seq = '())
  (for w :sliding-across seq
         :windowing-by '(2 1 0 2 1 3 2 2)
         :skipping-by '(-1 2 -2 0 2 -1 1))
  (collecting w))
=&gt; NIL
</code></p>

<p><code>WINDOWING-BY</code> must be an integer or a list of integers. The behavior for a <code>NIL</code> value is undefined.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">iter
  <span class="paren2">(<span class="code">with seq = '<span class="paren3">(<span class="code">1 2 3 4 5 6 7 8 9</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">for w <span class="keyword">:sliding-across</span> seq
         <span class="keyword">:windowing-by</span> NIL
         <span class="keyword">:skipping-by</span> '<span class="paren3">(<span class="code">-1 2 -2 0 2 -1 1</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">collecting w</span>)</span></span>)</span>
=&gt; Undefined</span></code></pre>

<p>An empty <code>SKIPPING-BY</code> value returns <code>NIL</code>.</p>

<pre><code>(iter
  (with seq = '(1 2 3 4 5 6 7 8 9))
  (for w :sliding-across seq
         :windowing-by '(2 1 0 2 1 3 2 2)
         :skipping-by '())
  (collecting w))
=&gt; NIL
</code></pre>

<p>A <code>NIL</code> value is returned when the starting window size is greater than the length of the sequence.</p>

<pre><code>(iter
  (with seq = '(1 2 3 4 5 6 7 8 9))
  (for w :sliding-across seq
         :windowing-by 10
         :skipping-by 1)
  (collecting w))
=&gt; NIL
</code></pre>

<p>A <code>NIL</code> value is also returned when the starting skip size is greater than the list.</p>

<pre><code>(iter
  (with seq = '(1 2 3 4 5 6 7 8 9))
  (for w :sliding-across seq
         :windowing-by 0
         :skipping-by 10)
  (collecting w))
=&gt; (NIL)
</code></pre>

<p>When the window size is the identical to the length of the sequence, the sequence (nested in a list) is returned.
Following are the results on a 64bit Mac with a 2.3 GHz 8-Core Intel Core i9 processor and 16 GB 2667 MHz DDR4 of RAM.</p>

<pre><code>(iter
  (with seq = '(1 2 3 4 5 6 7 8 9))
  (for w :sliding-across seq
         :windowing-by '(9 2)
         :skipping-by 10)
  (collecting w))
=&gt; ((1 2 3 4 5 6 7 8 9))
</code></pre>

<p></details></p>

<p><strong>PERFORMANCE</strong></p>

<p>The driver is reasonably performant. An array sequence of 1 million elements takes less than 0.3s to process.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">flet</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">random-range <span class="paren4">(<span class="code">n</span>)</span> <span class="paren4">(<span class="code">- <span class="paren5">(<span class="code">random <span class="paren6">(<span class="code">1+ <span class="paren1">(<span class="code">* 2 n</span>)</span></span>)</span></span>)</span> n</span>)</span></span>)</span>
       <span class="paren3">(<span class="code">loop-random <span class="paren4">(<span class="code">f n</span>)</span> <span class="paren4">(<span class="code"><i><span class="symbol">loop</span></i> for i from 0 below 1000000 collect <span class="paren5">(<span class="code">funcall f n</span>)</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">time
    <span class="paren3">(<span class="code">iter
      <span class="paren4">(<span class="code">with seq = <span class="paren5">(<span class="code">make-array 1000000 <span class="keyword">:initial-contents</span> <span class="paren6">(<span class="code">loop-random #'random 101</span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code">with win = <span class="paren5">(<span class="code">loop-random #'random 5</span>)</span></span>)</span>
      <span class="paren4">(<span class="code">with skip = <span class="paren5">(<span class="code">loop-random #'random-range 5</span>)</span></span>)</span>
      <span class="paren4">(<span class="code">for w <span class="keyword">:sliding-across</span> seq <span class="keyword">:windowing-by</span> win <span class="keyword">:skipping-by</span> skip</span>)</span></span>)</span></span>)</span></span>)</span>

.. Evaluation took:
..   0.145 seconds of real time
..   0.146188 seconds of total run time <span class="paren1">(<span class="code">0.137569 user, 0.008619 system</span>)</span>
..   [ Run times consist of 0.053 seconds GC time, and 0.094 seconds non-GC time. ]
..   100.69% CPU
..   336,167,382 processor cycles
..   73,595,808 bytes consed
=&gt; NIL</span></code></pre>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">flet</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">loop-random <span class="paren4">(<span class="code">f n</span>)</span> <span class="paren4">(<span class="code"><i><span class="symbol">loop</span></i> for i from 0 below 1000000 collect <span class="paren5">(<span class="code">funcall f n</span>)</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">time
    <span class="paren3">(<span class="code">iter
      <span class="paren4">(<span class="code">with seq = <span class="paren5">(<span class="code">make-array 1000000 <span class="keyword">:initial-contents</span> <span class="paren6">(<span class="code">loop-random #'random 101</span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code">for w <span class="keyword">:sliding-across</span> seq <span class="keyword">:windowing-by</span> 2 <span class="keyword">:skipping-by</span> -1</span>)</span></span>)</span></span>)</span></span>)</span>

.. Evaluation took:
..   0.224 seconds of real time
..   0.225691 seconds of total run time <span class="paren1">(<span class="code">0.176494 user, 0.049197 system</span>)</span>
..   [ Run times consist of 0.135 seconds GC time, and 0.091 seconds non-GC time. ]
..   100.89% CPU
..   518,013,836 processor cycles
..   88,001,104 bytes consed
=&gt; NIL</span></code></pre>

<p><a id='x-28GLITFENESTRO-3A-40WINDOWING-IF-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28GLITFENESTRO-3A-40WINDOWING-BY-20MGL-PAX-3ASECTION-29" title="WINDOWING-BY">&#8592;</a> <a href="#x-28GLITFENESTRO-3A-40ITERATE-20MGL-PAX-3ASECTION-29" title="Iterate Drivers">&#8593;</a> <a href="#x-28GLITFENESTRO-3A-40WINDOWING-IF-20MGL-PAX-3ASECTION-29" title="WINDOWING-IF">&#8634;</a></span></span></p>

<h3><a href="#x-28GLITFENESTRO-3A-40WINDOWING-IF-20MGL-PAX-3ASECTION-29">3.2 WINDOWING-IF</a></h3>

<p><strong>DEFINITION</strong></p>

<pre><code><span class="code">FOR binding-form SLIDING-ACROSS seq WINDOWING-IF window-predicate</span></code></pre>

<p><strong>SYNOPSIS</strong></p>

<p>Iterate by window consisting of consecutive elements satisifying <code>WINDOW-PREDICATE</code> sliding across a sequence</p>

<p><strong><code>KEYWORD</code> ARGUMENTS</strong></p>

<p><code>BINDING-FORM</code> -- a variable or two-variable proper list</p>

<p><code>SEQ</code> -- a proper sequence</p>

<p><code>WINDOW-PREDICATE</code> -- a designator for a function of one argument that returns a generalized boolean</p>

<p><strong><code>RETURN</code> <code>VALUES</code></strong></p>

<p>For each iteration, a sub-sequence of consecutive elements satisfying <code>WINDOW-PREDICATE</code>.</p>

<p><strong>DESCRIPTION</strong></p>

<p>A single variable <code>BINDING-FORM</code> contains the window sub-sequence for each iteration. For a list pair <code>BINDING-FORM</code>, the first variable contains the window sub-sequence and the second is a list pair containing the window start and end indices.</p>

<p>This driver is useful when iterating a sliding window across a sequence. Each iteration returns a sub-sequence consisting of consecutive elements that satisfy a given predicate.</p>

<p><strong>NOTES</strong></p>

<p>The following is assumed in all examples that follow,</p>

<pre><code><span class="code">CL-USER&gt; <span class="paren1">(<span class="code">ql:quickload <span class="keyword">:glitfenestro</span></span>)</span>
CL-USER&gt; <span class="paren1">(<span class="code">ql:quickload <span class="keyword">:iterate</span></span>)</span>
CL-USER&gt; <span class="paren1">(<span class="code">use-package <span class="keyword">:iterate</span></span>)</span></span></code></pre>

<p><details open>
<summary> <strong><em>Basic Use</em></strong> </summary></p>

<p>The most basic use is with a sequence and a <code>WINDOWING-IF</code> predicate function,</p>

<pre><code>(iter
  (with seq = '(1 3 5 2 6 7 9 4 8 4 3 2 8 8 8 9 0 0 2 4 5 3))
  (for w :sliding-across seq :windowing-if #'oddp)
  (collect w))
=&gt; ((1 3 5) (7 9) (3) (9) (5 3))
</code></pre>

<p>The &quot;full form&quot; of the driver returns two values: (1) the window and (2) a 2 element list with the start and end indices of each window group,</p>

<pre><code>(iter
  (with seq = '(1 1 1 1 2 2 2 3 3 3 2 2 4 4 4 1 1 5 5 5))
  (for (w i) :sliding-across seq :windowing-if #'evenp)
  (collect (list w i)))
=&gt; (((2 2 2) (4 6)) ((2 2 4 4 4) (10 14)))
</code></pre>

<p><details>
<summary> <strong><em>Run Length Encoding</em></strong> </summary></p>

<p>The driver is very useful for sequences where repeated elements have to be categorized in some way. Consider the run length encoding (RLE) example below,</p>

<pre><code>(iter
  (with seq = '(1 1 1 2 2 2 2 3 3 4 4 4 4 5 5 5 5 5 5 5 6 7 7))
  (with group-elt = (elt seq 0))
  (for (w i) :sliding-across seq
             :windowing-if (lambda(x) (= group-elt x)))
  (collect (list (car w) (length w)) into result)
  (for second-index = (cadr i))
  (unless (&gt; (incf second-index) (length seq))
    (setf group-elt (elt seq second-index)))
  (finally (return result)))
=&gt; ((1 3) (2 4) (3 2) (4 4) (5 7) (6 1) (7 2))
</code></pre>

<p>Another example from <a href="https://www.rosettacode.org/wiki/Run-length_encoding" >Rosetta Code</a> illustrates RLE on strings,</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">iter
  <span class="paren2">(<span class="code">with str = <span class="string">"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW"</span></span>)</span>
  <span class="paren2">(<span class="code">with group-elt = <span class="paren3">(<span class="code">elt str 0</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">for <span class="paren3">(<span class="code">w i</span>)</span> <span class="keyword">:sliding-across</span> str
             <span class="keyword">:windowing-if</span> <span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i><span class="paren4">(<span class="code">x</span>)</span> <span class="paren4">(<span class="code">equalp group-elt x</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">collect <span class="paren3">(<span class="code">list <span class="paren4">(<span class="code">elt w 0</span>)</span> <span class="paren4">(<span class="code">length w</span>)</span></span>)</span> into result</span>)</span>
  <span class="paren2">(<span class="code">for second-index = <span class="paren3">(<span class="code">cadr i</span>)</span></span>)</span>
  <span class="paren2">(<span class="code">unless <span class="paren3">(<span class="code">&gt;= <span class="paren4">(<span class="code">incf second-index</span>)</span> <span class="paren4">(<span class="code">length str</span>)</span></span>)</span>
    <span class="paren3">(<span class="code">setf group-elt <span class="paren4">(<span class="code">elt str second-index</span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">finally <span class="paren3">(<span class="code">return result</span>)</span></span>)</span></span>)</span>
=&gt; <span class="paren1">(<span class="code"><span class="paren2">(<span class="code">#W 12</span>)</span> <span class="paren2">(<span class="code">#B 1</span>)</span> <span class="paren2">(<span class="code">#W 12</span>)</span> <span class="paren2">(<span class="code">#B 3</span>)</span> <span class="paren2">(<span class="code">#W 24</span>)</span> <span class="paren2">(<span class="code">#B 1</span>)</span> <span class="paren2">(<span class="code">#W 14</span>)</span></span>)</span></span></code></pre>

<p></details></p>

<p><details>
<summary> <strong><em>Split Strings by Delimiter</em></strong> </summary></p>

<p>A natural use case for the driver is to split strings by a delimiter,</p>

<pre><code><span class="code"><span class="paren1">(<span class="code">iter
  <span class="paren2">(<span class="code">with str = <span class="string">"The quick brown fox jumps over the lazy dog"</span></span>)</span>
  <span class="paren2">(<span class="code">for w <span class="keyword">:sliding-across</span> str
         <span class="keyword">:windowing-if</span> <span class="paren3">(<span class="code"><i><span class="symbol">lambda</span></i> <span class="paren4">(<span class="code">x</span>)</span> <span class="paren4">(<span class="code">not <span class="paren5">(<span class="code">equalp x #Space</span>)</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">collect w</span>)</span></span>)</span>
=&gt; <span class="paren1">(<span class="code"><span class="string">"The"</span> <span class="string">"quick"</span> <span class="string">"brown"</span> <span class="string">"fox"</span> <span class="string">"jumps"</span> <span class="string">"over"</span> <span class="string">"the"</span> <span class="string">"lazy"</span> <span class="string">"dog"</span></span>)</span></span></code></pre>

<p>The <code>cl-ppcre</code> package is better suited for windowing by regex.</p>

<p></details></p>

<p><details>
<summary> <strong><em>Filtering</em></strong> </summary></p>

<p>The <code>WINDOWING-IF</code> predicate obviously lends itself to filtering functionality,</p>

<pre><code>(iter
  (with mat = #(#(1 3 2) #(-1 0 -3) #(9 6 8)))
  (for w :sliding-across mat
         :windowing-if (lambda (x) (every #'plusp x)))
  (collect w))
=&gt; (#(#(1 3 2)) #(#(9 6 8)))
</code></pre>

<p></details></p>

<p><details>
<summary> <strong><em>Edge Cases</em></strong> </summary></p>

<p>An empty sequence returns <code>NIL</code>,</p>

<pre><code>(iter
  (with seq = '())
  (for w :sliding-across seq :windowing-if #'zerop)
  (collect w))
=&gt; NIL
</code></pre>

<p><code>NIL</code> is also returned if no contigous elements satisfy the predicate,</p>

<pre><code>(iter
  (with seq = '(1 5 2 3 4))
  (for w :sliding-across seq :windowing-if #'zerop)
  (collect w))
=&gt; NIL
</code></pre>

<p></details></p>

<p><strong>PERFORMANCE</strong></p>

<p>The driver is reasonably performant. An array sequence of 1 million elements takes less than 0.3s to process.</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">flet</span></i> <span class="paren2">(<span class="code"><span class="paren3">(<span class="code">random-range <span class="paren4">(<span class="code">n</span>)</span> <span class="paren4">(<span class="code">- <span class="paren5">(<span class="code">random <span class="paren6">(<span class="code">1+ <span class="paren1">(<span class="code">* 2 n</span>)</span></span>)</span></span>)</span> n</span>)</span></span>)</span>
       <span class="paren3">(<span class="code">loop-random <span class="paren4">(<span class="code">f n</span>)</span> <span class="paren4">(<span class="code"><i><span class="symbol">loop</span></i> for i from 0 below 1000000 collect <span class="paren5">(<span class="code">funcall f n</span>)</span></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="code">time
    <span class="paren3">(<span class="code">iter
      <span class="paren4">(<span class="code">with seq = <span class="paren5">(<span class="code">make-array 1000000 <span class="keyword">:initial-contents</span> <span class="paren6">(<span class="code">loop-random #'random 101</span>)</span></span>)</span></span>)</span>
       <span class="paren4">(<span class="code">for w <span class="keyword">:sliding-across</span> seq <span class="keyword">:windowing-if</span> #'plusp</span>)</span></span>)</span></span>)</span></span>)</span>

.. Evaluation took:
..   0.125 seconds of real time
..   0.126364 seconds of total run time <span class="paren1">(<span class="code">0.074001 user, 0.052363 system</span>)</span>
..   [ Run times consist of 0.067 seconds GC time, and 0.060 seconds non-GC time. ]
..   100.80% CPU
..   289,933,222 processor cycles
..   32,118,304 bytes consed
=&gt; NIL</span></code></pre>

<p><br> <br></p>

<hr/>

<p><a name="r-slider">1</a>: <a href="https://cran.r-project.org/web/packages/slider/vignettes/slider.html" >Slider R Package</a></p>
  </div>
</div>
<script>$('#page-toc').toc({'selectors': 'h1,h2,h3,h4'});</script>
</body>
</html>
